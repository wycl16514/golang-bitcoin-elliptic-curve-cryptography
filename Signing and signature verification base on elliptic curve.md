We have shown that given generator point G, and select a scalar e (big enough), we can compute P=e*G easily, but when you have G and P, its impossible to get e. 
This is the basic for elliptic curve graphy.

The scalar k we selected is called private key, and Q is public key, notice that k is a 256 bits integer and Q contains two part one is the x coordinate and the other
is y coordinate. 

The public key cryptography has its name as Elliptic Curve Digital Signature Algorithm, known as ECDSA for short. It invovles following steps:

1, select a scalar e, and compute P = e*G, e is private key and P is public key, realse P to public and every one can know it.

2, the owner of private key randomly select two finite field member u, v, and compute k = u + ve , k need to keep secret.

3, compute R = k * G = (u + v*e)*G = u*G + v*(e*G) = u*G+v*P, we only use the x coordinate of R, and name the value of x as r

4, the owner of private key generate a given message in text format with any length(it can be published), and hash it to a 256 bits number by using sha256 or md5, 
name this hash result as z，

5, compute a number s by s = (z + r*e) / k (all these computation are base on modulur p)

6, realse the turple (z, s，r) as the signiture of the private key owner

7, any one who want to make sure the message is really created by the owner of the private key, he or she can do the following steps:
   
   1, compute u = z / s, v = r / s,
   
   2, compute u* G + v * P = (z/s)*G + (r/s)*P = (z/s)*G + (r/s)*(e*G) = (z/s)*G + (re/s)*G = ((z+re)/s)*G = k*G = R',
   take the x coordinate of R' and check it with r, if they are the same, then we can be sure that message z is really created by the owner of the private key

   3. notice we have shown that n * G is identity, therefore the above computation related to z, s, r, e need to do base on mudulur of n, and remember the operator
      "/" is not the normal arithmetic divide , its the inverse of  multilication.

Let's put these steps into code as following, first add a new file named signature.go
```go
package elliptic_curve

import (
	"fmt"
)

type Signature struct {
	r *FieldElement
	s *FieldElement
}

func NewSignature(r *FieldElement, s *FieldElement) *Signature {
	return &Signature{
		r: r,
		s: s,
	}
}

func (s *Signature) String() string {
	return fmt.Sprintf("Signature(r: {%s}, s:{%s})", s.r, s.s)
}

```
it contains two components, one is r, and the other is s, they will be used for verify. Second we add a new function for FieldElement, this fuction used to get
the inverse of the current field element:
```go
func (f *FieldElement) Inverse() *FieldElement {
	//use Fermat's little theorem to get the reverse of the given field element
	var op big.Int
	return f.Power(op.Sub(f.order, big.NewInt(int64(2))))
}
```
Let's go to point.go and add the verify function:
```go
func (p *Point) getGenerator() *Point {
	Gx := new(big.Int)
	Gx.SetString("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", 16)
	Gy := new(big.Int)
	Gy.SetString("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", 16)
	G := S256Point(Gx, Gy)
	return G
}

func (p *Point) Verify(z *FieldElement, sig *Signature) bool {
	/*
		7. any one who want to verify message z is created by owner of e:
		    1, compute u = z/s, v=r/s,
			2, compute u*G + v*P = (z/s)*G + (r/s)*P = (z/s)*G+(r/s)*eG
				=(z/s)*P + (r*e/s)*G = ((z+r*e)/s))*G = k*G = R'
			3, take the x coordinate of R' compare with r
				if the same => verify the message z is created by owner of e

			notice we have shown that n * G is identity, therefore the above computation related to z, s, r, e need to do base on mudulur of n, and remember the operator
			"/" is not the normal arithmetic divide , its the inverse of  multilication.
	*/
	sInverse := sig.s.Inverse()
	u := z.Multiply(sInverse)
	v := sig.r.Multiply(sInverse)
	G := p.getGenerator()
	total := (G.ScalarMul(u.num)).Add(p.ScalarMul(v.num))

	return total.x.num.Cmp(sig.r.num) == 0
}
```

Let's run the Verify function for testing, in main.go:
```go
package main

import (
	ecc "elliptic_curve"
	"fmt"
	"math/big"
)

func main() {
	/*
        P(x,y)= (
             0x4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574，
             82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4
		)

		z: 0xbc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423
		r: 37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
		s: 8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec

		R is public key used to verify the message, z is hashed message,
		s is generated by using z and private key e,
		Verify should return true
	*/
	n := new(big.Int)
	n.SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)

	zVal := new(big.Int)
	zVal.SetString("bc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423", 16)
	zField := ecc.NewFieldElement(n, zVal)

	rVal := new(big.Int)
	rVal.SetString("37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6", 16)
	rField := ecc.NewFieldElement(n, rVal)

	sVal := new(big.Int)
	sVal.SetString("8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec", 16)
	sField := ecc.NewFieldElement(n, sVal)

	//public key
	px := new(big.Int)
	px.SetString("4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574", 16)
	py := new(big.Int)
	py.SetString("82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4", 16)
	point := ecc.S256Point(px, py)
	//	fmt.Printf("point is: %s\n", point)

	sig := ecc.NewSignature(rField, sField)
	verifyRes := point.Verify(zField, sig)
	fmt.Printf("verify result is %v\n", verifyRes)
}
```

Run the above code you will get following result:

```go
verify result is true
```

Practise:
given public key P=(0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c, 0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)
verify following two signatures:

# signature 1
z = 0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
r = 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
s = 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4
# signature 2
z = 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
r = 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
s = 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6

Let's see how we can do the signing process:
1, given a text message, using sha256 to hash it twice into a 256 bits integer which is z, 
do sha256 twice is for security reason, because it is found that one time of sha256 may be reversible,
that is people can get the 256 integer and recreate the original text used for the hash, do twice can prevent such 
problem.

2, Create a private key e, this can be done by a sha256 on a text and compute public key P = e * G

3. Choosing a random number k, compute R = k * G and get r as the x coordinate of R

4. compute s = (z + r * e) / k, notice the "/ k" is the inverse of k

5. return the signature (r, s)

let's see how to use code to that it，first let's add a new file named util.go and we put all helper function into it:

```go
package elliptic_curve

import (
	"crypto/sha256"
	"math/big"
)

func Hash256(text string) []byte {
	/*
		doing sha256 twice
	*/
	hashOnce := sha256.Sum256([]byte(text))
	hashTwice := sha256.Sum256(hashOnce[:])
	return hashTwice[:]
}

func getGenerator() *Point {
	Gx := new(big.Int)
	Gx.SetString("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", 16)
	Gy := new(big.Int)
	Gy.SetString("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", 16)
	G := S256Point(Gx, Gy)
	return G
}

func GetBitcoinValueN() *big.Int {
	n := new(big.Int)
	n.SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)
	return n
}
```

The above functions are used in many places, notice we move the  getGenerator from the point struct and we need to 
make conresponding changes in point.go, we add another new file named private-key.go, and add the following code:

```go
package elliptic_curve

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

type PrivateKey struct {
	secret *big.Int
	point  *Point
}

func NewPrivateKey(secret *big.Int) *PrivateKey {
	G := getGenerator()

	return &PrivateKey{
		secret: secret,
		point:  G.ScalarMul(secret),
	}
}

func (p *PrivateKey) String() string {
	return fmt.Sprintf("private key hex: {%s}", p.secret)
}

func (p *PrivateKey) GetPublicKey() *Point {
	G := getGenerator()
	return G.ScalarMul(p.secret)
}

func (p *PrivateKey) Sign(z *big.Int) *Signature {
	n := GetBitcoinValueN()
	//select random number in the range of n
	//k can't use twice otherwise private will revealed
	k, err := rand.Int(rand.Reader, n)
	kField := NewFieldElement(n, k)
	if err != nil {
		panic(fmt.Sprintf("Sign err with rand int: %s\n", err))
	}
	G := getGenerator()
	r := G.ScalarMul(k).x.num
	//s = (z + r * e) / k, base on mudulur n
	rField := NewFieldElement(n, r)
	eField := NewFieldElement(n, p.secret)
	zField := NewFieldElement(n, z)
	rMulSecret := rField.Multiply(eField)
	zAddRmulSecret := zField.Add(rMulSecret)
	kInverse := kField.Inverse()
	sField := zAddRmulSecret.Multiply(kInverse)
	var opDiv big.Int
	if sField.num.Cmp(opDiv.Div(n, big.NewInt(int64(2)))) > 0 {
	        /*
	         if s > n / 2 we need to change it to n - s, when doing signature
	         verify, s and n - s are equivalence doing this change is for malleability reasons, detail:
	         https://bitcoin.stackexchange.com/questions/85946/low-s-value-in-bitcoin-signature
	         */
		var opSub big.Int
		sField = NewFieldElement(n, opSub.Sub(n, sField.num))
	}
	return &Signature{
		r: NewFieldElement(n, r),
		s: sField,
	}

}
```

The sign function is used for signature, the input parameter z is the hashed 256 bits integer, remember any operation
like multiply or divide are base on mudulur n, that's why we create FieldElement object to do the operation.

We need to pay attetion to the value of s, if its value is bigger than n/2, than we can change it to n - s without 
having any effect on the signature and verify, this is required by bitcoin blockchain.

let's use the above code to create a signature and verify , following is the code for main.go:

```go
package main

import (
	ecc "elliptic_curve"
	"fmt"
	"math/big"
)

func main() {
	e := big.NewInt(int64(12345))
	z := new(big.Int)
	z.SetBytes(ecc.Hash256("Tesing my Signing"))

	privateKey := ecc.NewPrivateKey(e)
	sig := privateKey.Sign(z)
	fmt.Printf("sig is %s\n", sig)

	pubKey := privateKey.GetPublicKey()
	n := ecc.GetBitcoinValueN()
	zField := ecc.NewFieldElement(n, z)
	res := pubKey.Verify(zField, sig)
	fmt.Printf("verify signature result: %v\n", res)
}
```

Running the above code can get the following result:

```go
sig is Signature(r: {FieldElement{order: 115792089237316195423570985008687907852837564279074904382605163141518161494337, num: 34760265646743494300414826834746237430743723107036364618855713969497218599817}}, s:{FieldElement{order: 115792089237316195423570985008687907852837564279074904382605163141518161494337, num: 6051507193975158704644645619286490297172153466045651190239770626531632363100}})
verify signature result: true
```

we can see the code can create the signature object and be verify by our verify function, and the logic circle can be
closed
