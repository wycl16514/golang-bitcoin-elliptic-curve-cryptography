We have shown that given generator point G, and select a scalar e (big enough), we can compute P=e*G easily, but when you have G and P, its impossible to get e. 
This is the basic for elliptic curve graphy.

The scalar k we selected is called private key, and Q is public key, notice that k is a 256 bits integer and Q contains two part one is the x coordinate and the other
is y coordinate. 

The public key cryptography has its name as Elliptic Curve Digital Signature Algorithm, known as ECDSA for short. It invovles following steps:

1, select a scalar e, and compute P = e*G, e is private key and P is public key, realse P to public and every one can know it.

2, the owner of private key randomly select two finite field member u, v, and compute k = u + ve , k need to keep secret.

3, compute R = k * G = (u + v*e)*G = u*G + v*(e*G) = u*G+v*P, we only use the x coordinate of R, and name the value of x as r

4, the owner of private key generate a given message in text format with any length(it can be published), and hash it to a 256 bits number by using sha256 or md5, 
name this hash result as z，

5, compute a number s by s = (z + r*e) / k (all these computation are base on modulur p)

6, realse the turple (z, s，r) as the signiture of the private key owner

7, any one who want to make sure the message is really created by the owner of the private key, he or she can do the following steps:
   
   1, compute u = z / s, v = r / s,
   
   2, compute u* G + v * P = (z/s)*G + (r/s)*P = (z/s)*G + (r/s)*(e*G) = (z/s)*G + (re/s)*G = ((z+re)/s)*G = k*G = R',
   take the x coordinate of R' and check it with r, if they are the same, then we can be sure that message z is really created by the owner of the private key

   3. notice we have shown that n * G is identity, therefore the above computation related to z, s, r, e need to do base on mudulur of n, and remember the operator
      "/" is not the normal arithmetic divide , its the inverse of  multilication.

Let's put these steps into code as following, first add a new file named signature.go
```g
package elliptic_curve

import (
	"fmt"
)

type Signature struct {
	r *FieldElement
	s *FieldElement
}

func NewSignature(r *FieldElement, s *FieldElement) *Signature {
	return &Signature{
		r: r,
		s: s,
	}
}

func (s *Signature) String() string {
	return fmt.Sprintf("Signature(r: {%s}, s:{%s})", s.r, s.s)
}

```
it contains two components, one is r, and the other is s, they will be used for verify. Second we add a new function for FieldElement, this fuction used to get
the inverse of the current field element:
```go
func (f *FieldElement) Inverse() *FieldElement {
	//use Fermat's little theorem to get the reverse of the given field element
	var op big.Int
	return f.Power(op.Sub(f.order, big.NewInt(int64(2))))
}
```
Let's go to point.go and add the verify function:
```go
func (p *Point) getGenerator() *Point {
	Gx := new(big.Int)
	Gx.SetString("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", 16)
	Gy := new(big.Int)
	Gy.SetString("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", 16)
	G := S256Point(Gx, Gy)
	return G
}

func (p *Point) Verify(z *FieldElement, sig *Signature) bool {
	/*
		7. any one who want to verify message z is created by owner of e:
		    1, compute u = z/s, v=r/s,
			2, compute u*G + v*P = (z/s)*G + (r/s)*P = (z/s)*G+(r/s)*eG
				=(z/s)*P + (r*e/s)*G = ((z+r*e)/s))*G = k*G = R'
			3, take the x coordinate of R' compare with r
				if the same => verify the message z is created by owner of e

			notice we have shown that n * G is identity, therefore the above computation related to z, s, r, e need to do base on mudulur of n, and remember the operator
			"/" is not the normal arithmetic divide , its the inverse of  multilication.
	*/
	sInverse := sig.s.Inverse()
	u := z.Multiply(sInverse)
	v := sig.r.Multiply(sInverse)
	G := p.getGenerator()
	total := (G.ScalarMul(u.num)).Add(p.ScalarMul(v.num))

	return total.x.num.Cmp(sig.r.num) == 0
}
```

Let's run the Verify function for testing, in main.go:
```go
package main

import (
	ecc "elliptic_curve"
	"fmt"
	"math/big"
)

func main() {
	/*
		R(x,y)= (
			0x4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574，
			82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4
		)

		z: 0xbc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423
		r: 37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
		s: 8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec

		R is public key used to verify the message, z is hashed message,
		s is generated by using z and private key e,
		Verify should return true
	*/
	n := new(big.Int)
	n.SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)

	zVal := new(big.Int)
	zVal.SetString("bc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423", 16)
	zField := ecc.NewFieldElement(n, zVal)

	rVal := new(big.Int)
	rVal.SetString("37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6", 16)
	rField := ecc.NewFieldElement(n, rVal)

	sVal := new(big.Int)
	sVal.SetString("8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec", 16)
	sField := ecc.NewFieldElement(n, sVal)

	//public key
	px := new(big.Int)
	px.SetString("4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574", 16)
	py := new(big.Int)
	py.SetString("82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4", 16)
	point := ecc.S256Point(px, py)
	//	fmt.Printf("point is: %s\n", point)

	sig := ecc.NewSignature(rField, sField)
	verifyRes := point.Verify(zField, sig)
	fmt.Printf("verify result is %v\n", verifyRes)
}
```
Run the above code you will get following result:
```g
verify result is true
```
